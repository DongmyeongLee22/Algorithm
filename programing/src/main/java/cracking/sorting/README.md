# 정렬과 탐색
> 정렬 및 탐색 문제는 잘 알려진 알고리즘들을 번용하여 출체된다. 그러므로 여러 가지 정렬 알고리즘의 차이점을 잘 이해하고, 해당 상황에서 어떤 알고리즘이 어울릴지 살펴두는 것이 좋다.

### 널리 사용되는 정렬 알고리즘
병합 정렬(merge sort), 퀵 정렬(quick sort), 버킷 정렬(bucket sort)의 문제가 가장 많이 출제된다.
<br>
버블 정렬
- 평균 및 최악 실행시간: O(n^2^), 메모리: O(1)
- 배열의 첫 원소부터 순차적으로 현재 원소와 그다음 원소를 비교하며 바꾸는 작업을 한다.

선택 정렬
  - 평균 및 최악 실행시간: O(n^2^), 메모리: O(1)
  - 아이들도 고안해낼 수 있는 단순한 알고리즘이나 비효율적
  - 배열을 선형 탐색하여 가장 작은 원소를 배열 맨 앞으로 보내고 그 원소랑 자리를 바꾼다. 그 다음에 두번째로 작은 원소를 찾은뒤 앞으로 보낸다.

병합 정렬
  - 평균 및 최악 실행시간: O(nlogn), 메모리: 상황에 따라 다르다.
  - 배열을 절반씩 나누어 각각을 정렬한 다음 이 둘을 합하여 다시 정렬
  - [MergeSort](MergeSort.java)
  - 마지막 코드에 왼쪽 절반만 복사하는데 오른쪽 절반은 이미 배열에 속해있기 때문이다.
  - 이 경우 공간복잡도는 O(n)이 된다.

퀵 정렬
  - 평균 실행시간: O(nlogn), 최악O(n^2^) 메모리: O(logn)
  - 피벗을 이용하여 그 피벗 값보다 작은 값을 왼쪽에 큰 값을 오른쪽에 보냄
  - 허나 피벗이 항상 첫번째나 마지막 값이되면 O(n^2^)이 걸리게 된다.
  - [QuickSort](QuickSort.java)
  - 피벗 중간값, 처음값으로 해보기

기수 정렬(radix sort)
  - 실행시간 O(n)
  - 유한한 비트로 구성되어 있을 때 사용한다.
  - 각 자릿수를 순회해 나가면서 각 자리의 값에 따라 그룹을 나눈다.

탐색 알고리즘
  - 이진탐색이 가장 대표적인 탐색 알고리즘
  - 정렬된 배열에서 원소 x를 찾을 때 사용한다.
  - x가 중간 위치 값보다 작으면 왼쪽 크면 오른쪽 탐색을 반복한다.
  - +1, -1을 잘 사용하자

### 문제
1. 정렬된 병합
- 두개의 정렬된 배열이 있을 때 A의 배열의 공간이 충분하다고 할때 A에 B를 넣으면서 정렬하기
- A와 B의 lastIndex를 알아야 풀수 있음
- A와 B를 비교하면서 마지막 인덱스 부터 값을 채우면 된다.
<br>
2. 회전될 배열 검색
- 정렬 된 배열을 임의 횟수로 회전 시킨 입력이 있을 떄 회전 전의 인덱스의 값을 찾기
- 회전의 의미가 애매하나 책에선 회전을 하더라도 중간인덱스의 왼쪽이나 오른쪽 하나는 정렬이 되어있다는 뜻이다.
- 그러므로 이진탐색을 응용하면된다.
- 중간인덱스를 구한 후 start가 중간인덱스보다 작으면 왼쪽이 정렬이므로 찾의려는 x값이 start ~ 중간인덱스 값이면 왼쪽 탐색 아니면 오른쪽 탐색
- start가 중간인덱스 보다 크면 오른쪽이 정렬이므로 위와 반대로
- 만약 start가 중간인덱스와 같을때는 end가 중간인덱스와 다르면 오른쪽을 탐색 아니면 둘다 탐색 해야한다.
<br>
3. 크기를 모르는 정렬된 원소 탐색: 인덱스 i에 위치한 값을 찾는 메서드가 주어짐, i가 범위를 넘어서면 -1를 반환
- 이진탐색을 해야할거 같다.
- 크기를 찾으면 바로 이진탐색이 가능하다.
- 크기를 어떻게 찾을까? 2제곱을 해가면서 찾으면 된다.
- 크기가 n이면 logn시간에 탐색이 가능하다.
- 이진탐색도 logn이므로 결국 길이를 모르더라도 전체 수행시간은 logn
- 인덱스 i의 값을 찾을 메서드를 사용하면서 -1 혹은 value 보다 큰 값을 반활할때 까지 i를 2씩 곱한다.
- 인덱스가 구해졌을때 인덱스/2 ~ 인덱스를 이진탐색하면 정답이 구해진다.
- 0 ~ 인덱스/2에 값이 있었다면 그전에 인덱스가 멈췄을 것임
<br>
4. 빈 문자열이 섞여 있는 정렬된 문자열이 주어졌을때 특정 문자를 탐색하는 메서드를 구현하라
- 이진탐색을 하면되지만 만약 중간값이 비어있으면 그 근처의 값을 찾아야 한다.
