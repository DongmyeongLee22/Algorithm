# 재귀와 동적 프로그래밍
재귀와 관련된 문제들은 많으며 상당수 패턴이 비슷하다. 주어진 문제가 재귀인지 알아보는 가장 좋은 방법은, 해당 문제를 작은 크기의 문제로 만들 수 있는지 보는 것이다.

재귀로 풀수 있는 문제일 확률이 높은 것들
- n번째 ~를 계산하는 알고리즘 설계
- 첫 n개를 나열하는 코드 작성
- 모든 ~를 계산하는 메서드 구현

### 접근법
#### 상향식(bottom-up)
- 가장 직관적인 경우가 많다. 이 접근법은 우선 간단한 경우드레 대한 풀이법을 발견하는 것으로부터 시작
- 리스트의 예로 처음에는 원소 하나를 갖는 리스트의 풀이,  다음은 원소 두개를 갖는 풀이, 다음은 세개를 갖는 풀이법을 찾아가는 것
- 즉 이전에 풀었던 사례를 확장하여 다음 풀이를 찾는 것

#### 하향식(top-down)
- 덜 명확해서 복잡해 보일 수 있다.
- But 가끔식 이 방법이 유용할 수도 있다.
- 어떻게 하면 N에 대한 문제를 부분으로 나눌 수 있을 지 생각해보는게 좋다.

#### 반반(half-and-half)
- 대표적으로 이진 탐색이 '반반 접근법'을 이용한 탐색법이다.

### 재귀적 해법 vs 순환적 해법
재귀적 해법
- 재귀적 알고리즘의 단점은 공간 효율성이 나빠질 수 있다.
- 재귀 호출이 한번 발생할 때마다 스택에 새로운 layer가 추가된다.
- 즉 재귀의 깊이가 n일때 공간 복잡도O(n)이 된다.

순환적 해법
- 모든 재귀적 알고리즘은 순환적 알고리즘으로 구현될 수 있다.
- 즉 재귀의 안좋은 공간 효율성을 메꿀수 있으나 코드가 훨씬 복잡하다.
- 문제를 풀때 순환적으로 풀면 얼마나 복잡해질지 잘 생각후 트레이드 오프하자

### 동적계획법 & 메모이제이션(memoization)
- 동적프로그래밍은 어려워 보이지만 실제 감을 잡으면 어렵지 않다.
- 대부분 재귀적 알고리즘과 반복적으로 호출되는 부분문제를 찾아내는 것이 관건(식을 잘세우면 된다.)
- 그렇게 구한 값들을 캐시에 저장해서 활용하면 된다.
- 사람에 따라 하향식 접근법을 메모이제이션, 상향식 접근법을 동적계획법이라고 구분하지만 둘 다 사실은 동적계획법의 범주에 속한다.


### 피보나치 수열
동적 계획법을 설명하기 가장 좋은 문제
#### 일반적인 재귀
```java
int fibonacci(int i) {
   if (i == 0) return 0;
   if (i == 1) return 1;
   return fibonacci(i - 1) + fibonacci(i - 2);
}
```
- 피보나치를 재귀로 풀떄의 시간복잡도를 생각해보자.
- 직접 그려보면 제일 왼쪽 트리의 레벨은 n이 될것이고 오른쪽으로 갈수록 level이 낮아질 것이다. 각 노드별 시간은 1이므로 노드수가 시간복잡도 이다.
- 노드수를 보면 약 2^n^-1개이다. 실제론 1.6^n^정도가 되지만 시간복잡도는 O(2^n^)이 된다.

#### 하향식 동적 프로그래밍(메모이제이션)
```java
int fibonacci1(int i) {
   return fibonacci1(i, new int[i + 1]);
}

int fibonacci1(int i, int[] val) {
   if (i == 0 || i == 1) return i;
   if (val[i] == 0) {
       val[i] = fibonacci1(i - 1, val) + fibonacci1(i - 2, val);
   }
   return val[i];
}
```
- 배열에 값들을 저장하면서 그 값들을 활용한 것을 알 수 있다.
- 메모이제이션 방법을 트리로 그려보면 트리수가 매우 적어진것을 알 수 있다.
- 약 2n개의 노드를 가지므로 시간복잡도는 O(n)이 된다.
- 실제 일반 재귀로 50번째 피보나치를 찾는데 몇십초가 걸리지만 동적 프로그래밍으로 1000번째 재귀를 찾으면 몇초도 안걸린다.

#### 상향식 동적 프로그래밍
```java
int fibonacci2(int n) {
    if (n == 0 || n == 1) return n;
    int val[] = new int[n];
    val[0] = 0;
    val[1] = 1;
    for (int i = 2; i < n; i++) {
        val[i] = val[i - 1] + val[i - 2];
    }

    return val[n - 1] + val[n - 2];
}
```
- 상향식으로 하면 반복을 통해 더 간단하게 풀 수 있다.
- val은 덧셈을 위해서만 사용되기 때문에 변수로도 풀 수 있다.
```java
int fibonacci3(int n) {
    if (n == 0 || n == 1) return n;
    int a = 0;
    int b = 1;
    for (int i = 2; i < n; i++) {
        int c = a + b;
        a = b;
        b = c;
    }
    return a + b;
}
```

#문제
### 트리플 스텝
- n개의 계단을 오른다.
- 한번에 1, 2, 3 계단을 오를 수 있다. n개 까지 계단오르는 방법은 총 몇개인가?
- n번째 계단을 올라가기 위해선 n-1번째 + n-2번째 + n-3번째 경우의 수를 더하면된다.

### 마술 인덱스
- 정렬된 배열에서 a[i] = i인 인덱스 찾기
1. 중복된 값이 없고 정렬일 때
- 이진탐색처럼 mid인덱스를 찾는다.
- i < a[i]라면 0 ~ mid - 1이고 반대는 mid + 1 ~ end가 된다.

2. 중복된 값이 있고 정렬일 때
- 중복된 값이 있을땐 양쪽 다 탐색해야하지만 생략가능한 부분들이 있다.
- {-3, -2, 2, 2, 3, 3, ~} 일때 mid 인덱스가 5라면 4는 생략이 가능하다.
- arr[5] = 3이기 때문에 arr[4] = 4일 순 없다.
- 즉 왼쪽 배열은 0 ~ min(5, 3)까지만 탐색하면 된다.
- 오른쪽 배열은 max(5, 3) ~ end까지만 탐색하면 된다.

### 리스트의 부분집합을 전부 반환하기
- 부분집합의 개수는 2^n^개이다.
- 각 원소는 자신이 존재하는 집합과 존재하지 않는 집합으로 나눌 수 있다.
- 모든 원소가 똑같은 속성을 가지므로 2^n^개가 된다.
- n번 재귀를 돌면서 ret개수가 1씩 증가하므로 시간복잡도는 n*2^n-1^ 1이므로 O(n*2^n^)이다. 공간복잡도도 동일
- 단순 반복문으로 풀기보다 재귀로 푸는게 더 편하다.
- 재귀로 index를 증가시키면서 최대가 되면 공집합을 넣고 그 후 로직을 잘 작성하면됨.

### 재귀 곱셈
- bigget, smaller 활용하여 분할정복하면된다.
- 홀수 일때는 한번더 플러스 해주자
